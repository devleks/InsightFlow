# InsightFlow - Database Schema (Vector Store)

InsightFlow utilizes **ChromaDB** as its vector store. ChromaDB is a specialized database designed for storing and querying vector embeddings, which are numerical representations of text or other data.

Unlike traditional relational databases, vector stores like ChromaDB are often less about rigid schemas with many tables and more about "collections" of embeddings and their associated metadata.

## 1. ChromaDB Collection Structure

InsightFlow uses a single primary collection within ChromaDB to store document chunks.

*   **Collection Name**: Configurable via `config.yaml` (e.g., `vector_store.collection_name`, defaults to `insightflow_collection`).

Each item within the collection represents a chunk of a document and consists of:

1.  **ID**: A unique identifier for the document chunk (often a UUID generated by Langchain or ChromaDB).
2.  **Embedding**: The vector embedding of the document chunk's text content. This is a high-dimensional array of floating-point numbers generated by the chosen embedding model.
    *   _Field Type_: Array of Floats (dimension depends on the embedding model, e.g., 1536 for OpenAI `text-embedding-ada-002`).
3.  **Document (Text Content)**: The actual text content of the document chunk.
    *   _Field Type_: String.
4.  **Metadata**: A dictionary of key-value pairs associated with the document chunk. This is crucial for filtering, source attribution, and providing context.

    Key metadata fields stored by InsightFlow include:

    *   `source` (String):
The      absolute or relative file path of the original document from which the chunk      originated.
        *   _Example_: `documents/my_research_paper.pdf`

    *   `page_number` (Integer, optional):
The      page number within the original document where this chunk is found (primarily      for PDF documents).
        *   _Constraint_: Extracted if available from `UnstructuredFileLoader` with `mode="elements"`.

    *   `page` (Integer, optional):
A      fallback or alternative key for page number, also extracted by document loaders.
        *   _Constraint_: InsightFlow prioritizes `page_number` if both are present.

    *   `start_index` (Integer, optional):
The      starting character index of this chunk within the original document content      (if `add_start_index=True` in `RecursiveCharacterTextSplitter`).

    *   Other metadata fields automatically added by `UnstructuredFileLoader` (e.g., `filename`, `filetype`, `last_modified`) may also be present if not filtered out. InsightFlow's use of `filter_complex_metadata` ensures that only simple data types (string, integer, float, boolean) are persisted to ChromaDB to avoid ingestion errors.

## 2. Relationships

There are no explicit foreign key relationships in the traditional SQL sense within a single ChromaDB collection. The relationship between chunks and their original documents is maintained via the `source` metadata field.

## 3. Constraints

*   **Metadata Values**: ChromaDB requires metadata values to be simple data types (string, integer, float, boolean). Dictionaries or lists as direct metadata values are not supported and will cause errors during ingestion (hence the use of `filter_complex_metadata` in InsightFlow).
*   **ID Uniqueness**: Document chunk IDs within a collection must be unique.

## 4. Data Flow and Interaction

1.  **Ingestion**: When documents are processed, `app.py` loads them, splits them into chunks, generates embeddings, and adds these (embedding, text content, metadata) to the ChromaDB collection.
2.  **Retrieval**: When a user asks a query, the query is embedded, and ChromaDB performs a similarity search (e.g., cosine similarity or L2 distance) against the embeddings in the collection to find the most relevant document chunks.
3.  The retrieved chunks (including their text content and metadata) are then used as context for the LLM.

## 5. Persistence

ChromaDB is configured in InsightFlow to persist its data to disk at a location specified in `config.yaml` (e.g., `vector_store.persist_directory`). This allows the application to retain processed documents across sessions, avoiding the need to re-embed everything on each startup unless a re-creation is forced.

## Tool Suggestions

While tools like `dbdiagram.io` or `drawSQL` are excellent for relational databases, visualizing a vector store schema is simpler:

*   A conceptual diagram showing a "Collection" containing "Items" (Chunks), where each Item has an Embedding Vector, Text Content, and a set of Metadata fields is usually sufficient.
*   ChromaDB itself may offer client-side utilities or methods to inspect collection schemas or a sample of records.
